// src/data/algorithmInfo.js
export const ALGORITHM_INFO = {
  bubbleSort: {
    description: "Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
    timeComplexity: "O(n²)",
    spaceComplexity: "O(1)",
    bestCase: "O(n)",
    stable: "Yes",
  },
  selectionSort: {
    description: "Selection Sort sorts an array by repeatedly finding the minimum element from the unsorted part and putting it at the beginning.",
    timeComplexity: "O(n²)",
    spaceComplexity: "O(1)",
    bestCase: "O(n²)",
    stable: "No",
  },
  mergeSort: {
    description: "Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(n)",
    bestCase: "O(n log n)",
    stable: "Yes",
  },
  insertionSort: {
    description: "Insertion Sort builds the final sorted array one item at a time by inserting each element into its correct position.",
    timeComplexity: "O(n²)",
    spaceComplexity: "O(1)",
    bestCase: "O(n)",
    stable: "Yes",
  },
  quickSort: {
    description: "Quick Sort is a divide-and-conquer algorithm that picks an element as a pivot and partitions the array around the pivot.",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(log n)",
    bestCase: "O(n log n)",
    stable: "No",
  },
  shellSort: {
    description: "Sorts elements at specific gaps, reducing the gap until it becomes 1 (like insertion sort).",
    timeComplexity: "O(n^1.5) to O(n²)",
    spaceComplexity: "O(1)",
    bestCase: "O(n log n)",
    stable: "No",
  },
  heapSort: {
    description: "Heap Sort uses a heap data structure to repeatedly extract the maximum element and place it at the end.",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(1)",
    bestCase: "O(n log n)",
    stable: "No",
  },
  radixSort: {
    description: "Radix Sort sorts numbers by processing individual digits. Works well for integers and has linear complexity relative to digits.",
    timeComplexity: "O(d * (n + k))",
    spaceComplexity: "O(n + k)",
    bestCase: "O(n)",
    stable: "Yes",
  },
  bucketSort: {
    description: "Bucket Sort distributes elements into buckets and sorts each bucket individually (often with insertion sort).",
    timeComplexity: "Average O(n + k)",
    spaceComplexity: "O(n + k)",
    bestCase: "O(n)",
    stable: "Yes (depends on bucket sorting)",
  },
  timSort: {
    description: "TimSort is a hybrid stable sorting algorithm derived from merge sort and insertion sort.",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(n)",
    bestCase: "O(n)",
    stable: "Yes",
  },
  introSort: {
    description: "IntroSort starts with quicksort and switches to heapsort when recursion depth gets too large to guarantee O(n log n).",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(log n)",
    bestCase: "O(n log n)",
    stable: "No",
  },
};
