[
    {
        "id": 1,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Bubble Sort?",
        "options": [
            "Bubble Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Bubble Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 2,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Bubble Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Bubble Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 3,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Bubble Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Bubble Sort has an average case of O(n log n)."
    },
    {
        "id": 4,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Bubble Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Bubble Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 5,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Bubble Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Bubble Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 6,
        "topic": "Sorting",
        "algorithm": "Bubble Sort",
        "difficulty": "Hard",
        "question": "What makes Bubble Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Bubble Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 7,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Selection Sort?",
        "options": [
            "Selection Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Selection Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 8,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Selection Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Selection Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 9,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Selection Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Selection Sort has an average case of O(n log n)."
    },
    {
        "id": 10,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Selection Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Selection Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 11,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Selection Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Selection Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 12,
        "topic": "Sorting",
        "algorithm": "Selection Sort",
        "difficulty": "Hard",
        "question": "What makes Selection Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Selection Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 13,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Insertion Sort?",
        "options": [
            "Insertion Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Insertion Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 14,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Insertion Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Insertion Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 15,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Insertion Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Insertion Sort has an average case of O(n log n)."
    },
    {
        "id": 16,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Insertion Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Insertion Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 17,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Insertion Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Insertion Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 18,
        "topic": "Sorting",
        "algorithm": "Insertion Sort",
        "difficulty": "Hard",
        "question": "What makes Insertion Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Insertion Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 19,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Merge Sort?",
        "options": [
            "Merge Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Merge Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 20,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Merge Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Merge Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 21,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Merge Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Merge Sort has an average case of O(n log n)."
    },
    {
        "id": 22,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Merge Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Merge Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 23,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Merge Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 2,
        "explanation": "Merge Sort requires O(n) extra space in the worst case."
    },
    {
        "id": 24,
        "topic": "Sorting",
        "algorithm": "Merge Sort",
        "difficulty": "Hard",
        "question": "What makes Merge Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Merge Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 25,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Quick Sort?",
        "options": [
            "Quick Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Quick Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 26,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Quick Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Quick Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 27,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Quick Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Quick Sort has an average case of O(n log n)."
    },
    {
        "id": 28,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Quick Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Quick Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 29,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Quick Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Quick Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 30,
        "topic": "Sorting",
        "algorithm": "Quick Sort",
        "difficulty": "Hard",
        "question": "What makes Quick Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Quick Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 31,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Tim Sort?",
        "options": [
            "Tim Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Tim Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 32,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Tim Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Tim Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 33,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Tim Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Tim Sort has an average case of O(n log n)."
    },
    {
        "id": 34,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Tim Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Tim Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 35,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Tim Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Tim Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 36,
        "topic": "Sorting",
        "algorithm": "Tim Sort",
        "difficulty": "Hard",
        "question": "What makes Tim Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Tim Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 37,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Intro Sort?",
        "options": [
            "Intro Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Intro Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 38,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Intro Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Intro Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 39,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Intro Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Intro Sort has an average case of O(n log n)."
    },
    {
        "id": 40,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Intro Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Intro Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 41,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Intro Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Intro Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 42,
        "topic": "Sorting",
        "algorithm": "Intro Sort",
        "difficulty": "Hard",
        "question": "What makes Intro Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Intro Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 43,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Easy",
        "question": "What is the basic idea of Shell Sort?",
        "options": [
            "Shell Sort compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Shell Sort is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 44,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Shell Sort?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Shell Sort can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 45,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Shell Sort?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Shell Sort has an average case of O(n log n)."
    },
    {
        "id": 46,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Shell Sort?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Shell Sort usually works directly on arrays in basic implementations."
    },
    {
        "id": 47,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Shell Sort?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Shell Sort requires O(1) extra space in the worst case."
    },
    {
        "id": 48,
        "topic": "Sorting",
        "algorithm": "Shell Sort",
        "difficulty": "Hard",
        "question": "What makes Shell Sort less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Shell Sort is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 49,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Easy",
        "question": "What is the basic idea of Linear Search?",
        "options": [
            "Linear Search compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Linear Search is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 50,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Linear Search?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Linear Search can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 51,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Linear Search?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Linear Search has an average case of O(n\u00b2)."
    },
    {
        "id": 52,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Linear Search?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Linear Search usually works directly on arrays in basic implementations."
    },
    {
        "id": 53,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Linear Search?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Linear Search requires O(1) extra space in the worst case."
    },
    {
        "id": 54,
        "topic": "Searching",
        "algorithm": "Linear Search",
        "difficulty": "Hard",
        "question": "What makes Linear Search less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Linear Search is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 55,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Easy",
        "question": "What is the basic idea of Binary Search?",
        "options": [
            "Binary Search compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Search is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 56,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Binary Search?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Binary Search can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 57,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Binary Search?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 1,
        "explanation": "Typically, Binary Search has an average case of O(n\u00b2)."
    },
    {
        "id": 58,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Binary Search?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Search usually works directly on arrays in basic implementations."
    },
    {
        "id": 59,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Binary Search?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Search requires O(1) extra space in the worst case."
    },
    {
        "id": 60,
        "topic": "Searching",
        "algorithm": "Binary Search",
        "difficulty": "Hard",
        "question": "What makes Binary Search less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Binary Search is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    
  {
    "id": 67,
    "topic": "Searching",
    "algorithm": "Search in Databases",
    "difficulty": "Hard",
    "question": "Which searching technique is typically used in databases to speed up retrieval?",
    "options": [
      "Linear Search",
      "Binary Search",
      "Indexing with B-trees or Hashing",
      "Graph Search"
    ],
    "correctAnswer": 2,
    "explanation": "Databases use indexing techniques like B-trees and hashing to allow fast retrieval of records based on keys."
  },
  {
    "id": 68,
    "topic": "Searching",
    "algorithm": "File Systems",
    "difficulty": "Hard",
    "question": "How do modern file systems optimize search for files by name?",
    "options": [
      "Using Trie-based indexing",
      "Using Linear Search on all files",
      "Storing filenames in a queue",
      "Performing BFS on disk blocks"
    ],
    "correctAnswer": 0,
    "explanation": "Many modern file systems use Trie-like or hash-based structures to optimize filename lookups, especially for autocomplete and path resolution."
  },
  {
    "id": 69,
    "topic": "Searching",
    "algorithm": "Search Engines",
    "difficulty": "Hard",
    "question": "Which data structure is heavily used in search engines to map keywords to documents?",
    "options": [
      "Linked List",
      "Hash Table",
      "Inverted Index",
      "Binary Heap"
    ],
    "correctAnswer": 2,
    "explanation": "Search engines use an inverted index, which maps keywords to the list of documents containing them, allowing fast keyword-based retrieval."
  },
  {
    "id": 70,
    "topic": "Searching",
    "algorithm": "Pattern Matching",
    "difficulty": "Hard",
    "question": "Which algorithm is commonly used for efficient substring search in large texts?",
    "options": [
      "Linear Search",
      "KMP Algorithm",
      "Quick Sort",
      "Depth First Search"
    ],
    "correctAnswer": 1,
    "explanation": "The Knuth-Morris-Pratt (KMP) algorithm preprocesses the pattern and performs efficient substring search without backtracking."
  },
  {
    "id": 71,
    "topic": "Searching",
    "algorithm": "Networking",
    "difficulty": "Hard",
    "question": "In routing tables, which searching technique is used to determine the best path?",
    "options": [
      "Linear Search through all routes",
      "Longest Prefix Match using Trie",
      "Depth-First Search",
      "Interpolation Search"
    ],
    "correctAnswer": 1,
    "explanation": "Routers use Longest Prefix Match, often implemented using a Trie, to find the most specific matching route in the routing table."
  },
  {
    "id": 72,
    "topic": "Searching",
    "algorithm": "Operating Systems",
    "difficulty": "Hard",
    "question": "How does an operating system quickly find a process in a process table?",
    "options": [
      "Using a sorted array with Binary Search",
      "Using a Hash Table for constant-time lookup",
      "Using Breadth First Search",
      "Using Exponential Search"
    ],
    "correctAnswer": 1,
    "explanation": "Most operating systems use hash tables to store and search for processes efficiently by process ID."
  },


{
    "id":78,
    "topic": "Searching",
    "algorithm": "Search in Graphs",
    "difficulty": "Hard",
    "question": "Which search algorithm is best suited for finding the shortest path in an unweighted graph?",
    "options": [
      "Depth First Search (DFS)",
      "Breadth First Search (BFS)",     
        "Dijkstra's Algorithm",
        "A* Search"
    ],
    "correctAnswer": 1,
    "explanation": "BFS is optimal for finding the shortest path in unweighted graphs as it explores all neighbors level by level." 
},
  {
    "id": 79,
    "topic": "Searching",
    "algorithm": "Linear Search",
    "difficulty": "Medium",
    "question": "Which of the following is the correct implementation of Linear Search in Python?",
    "options": [
      "def linear_search(arr, x):\n    for i in arr:\n        if arr[i] == x:\n            return i\n    return -1",
      "def linear_search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1",
      "def linear_search(arr, x):\n    if x in arr:\n        return x\n    return -1",
      "def linear_search(arr, x):\n    return arr.index(x)"
    ],
    "correctAnswer": 1,
    "explanation": "Option 2 is the correct implementation using index-based iteration. Option 1 has a bug; 'i' is the element, not index."
  },
  {
    "id": 80,
    "topic": "Searching",
    "algorithm": "Binary Search",
    "difficulty": "Medium",
    "question": "Which of the following correctly implements Binary Search (iterative)?",
    "options": [
      "def binary_search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1",
      "def binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1",
      "def binary_search(arr, x):\n    arr.sort()\n    return arr.index(x)",
      "def binary_search(arr, x):\n    return arr.find(x)"
    ],
    "correctAnswer": 1,
    "explanation": "Option 2 is the correct iterative Binary Search implementation. It requires the array to be sorted beforehand."
  },
{
    "id": 73,
    "topic": "Searching",
    "algorithm": "Linear Search",
    "difficulty": "Medium",
    "question": "In an unsorted array, what is the average number of comparisons Linear Search will make to find a target element?",
    "options": [
      "n/2",
      "n",
      "log n",
      "1"
    ],
    "correctAnswer": 0,
    "explanation": "On average, Linear Search will traverse about half of the elements to find the target, resulting in n/2 comparisons."
  },
  {
    "id": 81,
    "topic": "Searching",
    "algorithm": "Recursive Binary Search",
    "difficulty": "Medium",
    "question": "Which code snippet correctly implements Recursive Binary Search?",
    "options": [
      "def binary_search(arr, x):\n    mid = len(arr) // 2\n    if arr[mid] == x:\n        return mid\n    elif x < arr[mid]:\n        return binary_search(arr[:mid], x)\n    else:\n        return binary_search(arr[mid+1:], x)",
      "def binary_search(arr, x, low, high):\n    if low > high:\n        return -1\n    mid = (low + high) // 2\n    if arr[mid] == x:\n        return mid\n    elif arr[mid] > x:\n        return binary_search(arr, x, low, mid - 1)\n    else:\n        return binary_search(arr, x, mid + 1, high)",
      "def binary_search(arr, x):\n    return arr.index(x)",
      "def binary_search(arr, x, low, high):\n    return (low + high) // 2 if x in arr else -1"
    ],
    "correctAnswer": 1,
    "explanation": "Option 2 shows a correct recursive Binary Search using `low` and `high` pointers. Option 1 is close but inefficient due to slicing."
  },
  
  {
    "id": 83,
    "topic": "Searching",
    "algorithm": "Hash Table Lookup",
    "difficulty": "Medium",
    "question": "Which of the following is a correct way to search in a hash table (dictionary) in Python?",
    "options": [
      "if key in dict:\n    return dict[key]",
      "if dict.has_key(key):\n    return dict[key]",
      "if dict[key]:\n    return key",
      "dict.get(key)"
    ],
    "correctAnswer": 0,
    "explanation": "Using `key in dict` is the Pythonic and safe way to check existence before access. Option 2 uses deprecated syntax."
  },
  {
    "id": 84,
    "topic": "Searching",
    "algorithm": "Ternary Search",
    "difficulty": "Medium",
    "question": "Which of the following correctly divides the array in Ternary Search?",
    "options": [
      "mid = (low + high) // 2",
      "mid1 = low + (high - low) // 2\nmid2 = mid1 + 1",
      "mid1 = low + (high - low) // 3\nmid2 = high - (high - low) // 3",
      "mid1 = (low + high) // 3\nmid2 = 2 * mid1"
    ],
    "correctAnswer": 2,
    "explanation": "Ternary Search divides the array into three parts using `mid1 = low + (high - low)/3` and `mid2 = high - (high - low)/3`."
  }
,


    {
        "id": 61,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Easy",
        "question": "What is the basic idea of Linked List?",
        "options": [
            "Linked List compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Linked List is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 62,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Linked List?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Linked List can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 63,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Linked List?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Linked List has an average case of O(n\u00b2)."
    },
    {
        "id": 64,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Linked List?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Linked List usually works directly on arrays in basic implementations."
    },
    {
        "id": 65,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Linked List?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Linked List requires O(1) extra space in the worst case."
    },
    {
        "id": 66,
        "topic": "Data Structures",
        "algorithm": "Linked List",
        "difficulty": "Hard",
        "question": "What makes Linked List less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Linked List is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 67,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Easy",
        "question": "What is the basic idea of Stack?",
        "options": [
            "Stack compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Stack is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 68,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Stack?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Stack can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 69,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Stack?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Stack has an average case of O(n\u00b2)."
    },
    {
        "id": 70,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Stack?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Stack usually works directly on arrays in basic implementations."
    },
    {
        "id": 71,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Stack?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Stack requires O(1) extra space in the worst case."
    },
    {
        "id": 72,
        "topic": "Data Structures",
        "algorithm": "Stack",
        "difficulty": "Hard",
        "question": "What makes Stack less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Stack is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 73,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Easy",
        "question": "What is the basic idea of Queue?",
        "options": [
            "Queue compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Queue is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 74,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Queue?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Queue can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 75,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Queue?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Queue has an average case of O(n\u00b2)."
    },
    {
        "id": 76,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Queue?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Queue usually works directly on arrays in basic implementations."
    },
    {
        "id": 77,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Queue?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 0,
        "explanation": "Queue requires O(1) extra space in the worst case."
    },
    {
        "id": 78,
        "topic": "Data Structures",
        "algorithm": "Queue",
        "difficulty": "Hard",
        "question": "What makes Queue less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Queue is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    },
    {
        "id": 79,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Easy",
        "question": "What is the basic idea of Binary Tree?",
        "options": [
            "Binary Tree compares and processes elements step by step",
            "It uses dynamic programming",
            "It uses hashing",
            "It uses recursion with memoization"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Tree is based on a fundamental step-by-step process, not advanced techniques like DP or hashing."
    },
    {
        "id": 80,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Easy",
        "question": "What is the best case time complexity of Binary Tree?",
        "options": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 1,
        "explanation": "In the best case, Binary Tree can often achieve O(n), especially when data is already partially structured."
    },
    {
        "id": 81,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Medium",
        "question": "What is the average case time complexity of Binary Tree?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n\u00b2)",
            "O(log n)"
        ],
        "correctAnswer": 2,
        "explanation": "Typically, Binary Tree has an average case of O(n\u00b2)."
    },
    {
        "id": 82,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Medium",
        "question": "Which data structure is commonly associated with Binary Tree?",
        "options": [
            "Array",
            "Stack",
            "Queue",
            "Tree"
        ],
        "correctAnswer": 0,
        "explanation": "Binary Tree usually works directly on arrays in basic implementations."
    },
    {
        "id": 83,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Hard",
        "question": "What is the worst case space complexity of Binary Tree?",
        "options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n\u00b2)"
        ],
        "correctAnswer": 2,
        "explanation": "Binary Tree requires O(n) extra space in the worst case."
    },
    {
        "id": 84,
        "topic": "Data Structures",
        "algorithm": "Binary Tree",
        "difficulty": "Hard",
        "question": "What makes Binary Tree less efficient compared to advanced algorithms?",
        "options": [
            "Higher time complexity",
            "More space usage",
            "Not adaptive",
            "All of the above"
        ],
        "correctAnswer": 3,
        "explanation": "Binary Tree is often less efficient due to multiple factors like higher time complexity, space usage, and lack of adaptability."
    }
]
